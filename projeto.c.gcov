        -:    0:Source:projeto.c
        -:    0:Graph:teste_cov-projeto.gcno
        -:    0:Data:teste_cov-projeto.gcda
        -:    0:Runs:1
        -:    1:#include "projeto.h"
        -:    2:#include <stdio.h>
        -:    3:#include <ctype.h>
        -:    4:#include <string.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <stdbool.h>
        -:    7:
        -:    8:// Declarações globais
        -:    9:Tabuleiro stack[tamanhoStack];
        -:   10:int topoStack = -1;
        -:   11:
function formatoParaCoordenadas called 13 returned 100% blocks executed 100%
       13:   12:int formatoParaCoordenadas(char *input, int *x, int *y) {
       13:   13:    if (input == NULL || strlen(input) < 2) return 0;
branch  0 taken 12 (fallthrough)
branch  1 taken 1
branch  2 taken 10 (fallthrough)
branch  3 taken 2
        -:   14:
       10:   15:    if (!isalpha(input[0])) return 0;
branch  0 taken 7 (fallthrough)
branch  1 taken 3
        -:   16:
        -:   17:    // Converte letra para índice de linha, aceita maiúsculas e minúsculas
        7:   18:    *x = tolower(input[0]) - 'a';
        -:   19:
        -:   20:    // Verifica se o resto é só número (sem caracteres extras)
        7:   21:    char *ponteirofim;
        7:   22:    long numero = strtol(input + 1, &ponteirofim, 10);
call    0 returned 7
        -:   23:
        7:   24:    if (*ponteirofim != '\0') return 0;  // Há caracteres a mais após o número
branch  0 taken 4 (fallthrough)
branch  1 taken 3
        4:   25:    if (numero < 1) return 0;       // Número deve ser positivo
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -:   26:
        4:   27:    *y = (int)numero - 1;
        4:   28:    return 1;
        -:   29:}
        -:   30:
        -:   31:// Funções relacionadas ao tabuleiro
function imprimirTabuleiro called 2 returned 100% blocks executed 100%
        2:   32:void imprimirTabuleiro(char tabuleiro[26][1000], int linhas, int colunas) {
        8:   33:    for (int i = 0; i < linhas; i++) {
branch  0 taken 6 (fallthrough)
branch  1 taken 2
       24:   34:        for (int j = 0; j < colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:   35:            printf("%c ", tabuleiro[i][j]);
call    0 returned 18
        -:   36:        }
        6:   37:        printf("\n");
call    0 returned 6
        -:   38:    }
        2:   39:}
        -:   40:
function pintarDeBranco called 5 returned 100% blocks executed 100%
        5:   41:void pintarDeBranco(char tabuleiro[26][1000], int linhas, int colunas, int x, int y) {
        5:   42:    if (y >= 0 && y < linhas && x >= 0 && x < colunas) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:   43:        tabuleiro[y][x] = toupper(tabuleiro[y][x]);
        -:   44:    } else {
        2:   45:        printf("Coordenada fora dos limites.\n");
call    0 returned 2
        -:   46:    }
        5:   47:}
        -:   48:
function riscar called 5 returned 100% blocks executed 100%
        5:   49:void riscar(char tabuleiro[26][1000], int linhas, int colunas, int x, int y) {
        5:   50:    if (y >= 0 && y < linhas && x >= 0 && x < colunas) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:   51:        if (tabuleiro[y][x] != '\0') {
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:   52:            tabuleiro[y][x] = '#';
        -:   53:        } else {
        1:   54:            printf("Célula vazia, não pode ser riscada.\n");
call    0 returned 1
        -:   55:        }
        -:   56:    } else {
        2:   57:        printf("Coordenada fora dos limites.\n");
call    0 returned 2
        -:   58:    }
        5:   59:}
        -:   60:
        -:   61:// Função para transformar casas vizinhas de riscas em brancas, retornando se houve mudança
function pintar_vizinhos_de_branco called 1 returned 100% blocks executed 85%
        1:   62:int pintar_vizinhos_de_branco(Tabuleiro *t, int i, int j) {
        1:   63:    int mudou = 0;
        1:   64:    if (i > 0 && islower((unsigned char)t->tabuleiro[i - 1][j])) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:   65:        t->tabuleiro[i - 1][j] = toupper((unsigned char)t->tabuleiro[i - 1][j]);
        1:   66:        mudou = 1;
        -:   67:    }
        1:   68:    if (i < t->linhas - 1 && islower((unsigned char)t->tabuleiro[i + 1][j])) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:   69:        t->tabuleiro[i + 1][j] = toupper((unsigned char)t->tabuleiro[i + 1][j]);
    #####:   70:        mudou = 1;
        -:   71:    }
        1:   72:    if (j > 0 && islower((unsigned char)t->tabuleiro[i][j - 1])) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:   73:        t->tabuleiro[i][j - 1] = toupper((unsigned char)t->tabuleiro[i][j - 1]);
        1:   74:        mudou = 1;
        -:   75:    }
        1:   76:    if (j < t->colunas - 1 && islower((unsigned char)t->tabuleiro[i][j + 1])) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:   77:        t->tabuleiro[i][j + 1] = toupper((unsigned char)t->tabuleiro[i][j + 1]);
    #####:   78:        mudou = 1;
        -:   79:    }
        1:   80:    return mudou;
        -:   81:}
        -:   82:
        -:   83:// Funções de gerenciamento de estado
function stacks called 105 returned 100% blocks executed 100%
      105:   84:void stacks(Tabuleiro estado) {
      105:   85:    if (topoStack < tamanhoStack - 1) {
branch  0 taken 104 (fallthrough)
branch  1 taken 1
      104:   86:        topoStack++;
      104:   87:        stack[topoStack] = estado;
        -:   88:    } else {
        1:   89:        printf("Stack cheia. Não é possível guardar mais estados.\n");
call    0 returned 1
        -:   90:    }
      105:   91:}
        -:   92:
function desempilhar called 5 returned 100% blocks executed 100%
        5:   93:Tabuleiro desempilhar() {
        5:   94:    if (topoStack >= 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:   95:        return stack[topoStack--];
        -:   96:    } else {
        2:   97:        printf("Stack vazia.\n");
call    0 returned 2
        2:   98:        Tabuleiro vazio = {{{0}}, 0, 0};
        2:   99:        return vazio;
        -:  100:    }
        -:  101:}
        -:  102:
function guardar_estado called 101 returned 100% blocks executed 100%
      101:  103:void guardar_estado(Tabuleiro *t) {
      101:  104:    stacks(*t);
call    0 returned 101
      101:  105:}
        -:  106:
function desfazer called 2 returned 100% blocks executed 100%
        2:  107:void desfazer(Tabuleiro *t) {
        2:  108:    Tabuleiro tabuleiroAnterior = desempilhar();
call    0 returned 2
        2:  109:    if (tabuleiroAnterior.linhas > 0 && tabuleiroAnterior.colunas > 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  110:        *t = tabuleiroAnterior;
        -:  111:   // Funções auxiliares
        -:  112:    } else {
        1:  113:        printf("Não é possível desfazer mais ações.\n");
call    0 returned 1
        -:  114:    }
        2:  115:}
        -:  116:
        -:  117:// Funções de gravação e leitura
function gravarStack called 3 returned 100% blocks executed 100%
        3:  118:void gravarStack(char *nome) {
        3:  119:    FILE *f = fopen(nome, "w");
call    0 returned 3
        3:  120:    if (!f) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  121:        perror("Erro ao guardar a stack");
        1:  122:        return;
call    0 returned 1
        -:  123:    }
        -:  124:
        2:  125:    fprintf(f, "%d\n", topoStack);
call    0 returned 2
        -:  126:
        3:  127:    for (int i = 0; i <= topoStack; i++) {
call    0 returned 2
branch  1 taken 1
branch  2 taken 2 (fallthrough)
        1:  128:        fprintf(f, "%d %d\n", stack[i].linhas, stack[i].colunas);
call    0 returned 1
        3:  129:        for (int y = 0; y < stack[i].linhas; y++) {
call    0 returned 1
branch  1 taken 2
branch  2 taken 1 (fallthrough)
        6:  130:            for (int x = 0; x < stack[i].colunas; x++) {
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  131:                fputc(stack[i].tabuleiro[y][x], f);
call    0 returned 4
        -:  132:            }
        2:  133:            fputc('\n', f);
call    0 returned 2
        -:  134:        }
        -:  135:    }
        -:  136:
        2:  137:    fclose(f);
call    0 returned 2
        -:  138:}
        -:  139:
function gravarJogo called 2 returned 100% blocks executed 100%
        2:  140:void gravarJogo(char *nome, Tabuleiro *t) {
        2:  141:    FILE *arquivo = fopen(nome, "w");
call    0 returned 2
        2:  142:    if (arquivo == NULL) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  143:        perror("Erro ao abrir tabuleiro.txt");
        1:  144:        return;
call    0 returned 1
        -:  145:    }
        -:  146:
        1:  147:    fprintf(arquivo, "%d %d\n", t->colunas, t->linhas);
call    0 returned 1
        -:  148:
        3:  149:    for (int i = 0; i < t->linhas; i++) {
call    0 returned 1
branch  1 taken 2
branch  2 taken 1 (fallthrough)
        6:  150:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  151:            fputc(t->tabuleiro[i][j], arquivo);
call    0 returned 4
        -:  152:        }
        2:  153:        fputc('\n', arquivo);
call    0 returned 2
        -:  154:    }
        -:  155:
        1:  156:    fclose(arquivo);
call    0 returned 1
        1:  157:    gravarStack("stack.txt");
call    0 returned 1
        -:  158:}
        -:  159:
function lerStack called 8 returned 100% blocks executed 100%
        8:  160:void lerStack(char *nome) {
        8:  161:    FILE *f = fopen(nome, "r");
call    0 returned 8
        8:  162:    if (!f) {
branch  0 taken 4 (fallthrough)
branch  1 taken 4
        4:  163:        topoStack = -1;
        4:  164:        return;
        -:  165:    }
        -:  166:
        4:  167:    if (fscanf(f, "%d\n", &topoStack) != 1) {
call    0 returned 4
branch  1 taken 1 (fallthrough)
branch  2 taken 3
        1:  168:        fclose(f);
call    0 returned 1
        1:  169:        topoStack = -1;
        1:  170:        return;
        -:  171:    }
        -:  172:
        4:  173:    for (int i = 0; i <= topoStack; i++) {
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        2:  174:        if (fscanf(f, "%d %d\n", &stack[i].linhas, &stack[i].colunas) != 2) {
call    0 returned 2
branch  1 taken 1 (fallthrough)
branch  2 taken 1
        1:  175:            topoStack = i - 1;
        1:  176:            break;
        -:  177:        }
        -:  178:
        3:  179:        for (int y = 0; y < stack[i].linhas; y++) {
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        6:  180:            for (int x = 0; x < stack[i].colunas; x++) {
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  181:                stack[i].tabuleiro[y][x] = fgetc(f);
call    0 returned 4
        -:  182:            }
        2:  183:            fgetc(f);
call    0 returned 2
        -:  184:        }
        -:  185:    }
        -:  186:
        3:  187:    fclose(f);
call    0 returned 3
        -:  188:}
        -:  189:
function lerJogo called 6 returned 100% blocks executed 100%
        6:  190:void lerJogo(char *nome, Tabuleiro *t) {
        6:  191:    FILE *f = fopen(nome, "r");
call    0 returned 6
        6:  192:    if (!f) {
branch  0 taken 2 (fallthrough)
branch  1 taken 4
        2:  193:        printf("Erro ao abrir ficheiro: %s\n", nome);
call    0 returned 2
        2:  194:        return;
call    0 returned 2
        -:  195:    }
        -:  196:
        4:  197:    if (fscanf(f, "%d %d", &t->colunas, &t->linhas)!=2){
call    0 returned 4
branch  1 taken 2 (fallthrough)
branch  2 taken 2
        2:  198:        printf("Erro a ler tabuleiro.\n");
call    0 returned 2
        4:  199:    };
        4:  200:    fgetc(f);
        -:  201:
       12:  202:    for (int i = 0; i < t->linhas; i++) {
call    0 returned 4
branch  1 taken 8
branch  2 taken 4 (fallthrough)
       30:  203:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 22
branch  1 taken 8 (fallthrough)
       22:  204:            t->tabuleiro[i][j] = fgetc(f);
call    0 returned 22
        -:  205:        }
        8:  206:        fgetc(f);
call    0 returned 8
        -:  207:    }
        -:  208:
        4:  209:    fclose(f);
call    0 returned 4
        4:  210:    lerStack("stack.txt");
call    0 returned 4
        -:  211:}
        -:  212:
        -:  213:// Funções de verificação e regras
function verificar_riscadas called 6 returned 100% blocks executed 100%
        6:  214:void verificar_riscadas(char tabuleiro[26][1000], int linhas, int colunas) {
       23:  215:    for (int i = 0; i < linhas; i++) {
branch  0 taken 17
branch  1 taken 6 (fallthrough)
       66:  216:        for (int j = 0; j < colunas; j++) {
branch  0 taken 49
branch  1 taken 17 (fallthrough)
       49:  217:            if (tabuleiro[i][j] == '#') {
branch  0 taken 18 (fallthrough)
branch  1 taken 31
       18:  218:                int brancas = 0;
       18:  219:                int vizinhas = 0;
        -:  220:
        -:  221:                // Cima
       18:  222:                if (i > 0) {
branch  0 taken 13 (fallthrough)
branch  1 taken 5
       13:  223:                    vizinhas++;
       13:  224:                    if (isupper(tabuleiro[i-1][j])) brancas++;
branch  0 taken 12 (fallthrough)
branch  1 taken 1
        -:  225:                }
        -:  226:                // Baixo
       18:  227:                if (i < linhas-1) {
branch  0 taken 14 (fallthrough)
branch  1 taken 4
       14:  228:                    vizinhas++;
       14:  229:                    if (isupper(tabuleiro[i+1][j])) brancas++;
branch  0 taken 13 (fallthrough)
branch  1 taken 1
        -:  230:                }
        -:  231:                // Esquerda
       18:  232:                if (j > 0) {
branch  0 taken 13 (fallthrough)
branch  1 taken 5
       13:  233:                    vizinhas++;
       13:  234:                    if (isupper(tabuleiro[i][j-1])) brancas++;
branch  0 taken 12 (fallthrough)
branch  1 taken 1
        -:  235:                }
        -:  236:                // Direita
       18:  237:                if (j < colunas-1) {
branch  0 taken 14 (fallthrough)
branch  1 taken 4
       14:  238:                    vizinhas++;
       14:  239:                    if (isupper(tabuleiro[i][j+1])) brancas++;
branch  0 taken 13 (fallthrough)
branch  1 taken 1
        -:  240:                }
        -:  241:
        -:  242:                // Agora comparamos brancas com o número de vizinhas existentes
       18:  243:                if (brancas < vizinhas) {
branch  0 taken 1 (fallthrough)
branch  1 taken 17
        1:  244:                    char coluna = 'a' + j;      
        1:  245:                    int  linha  = i + 1;        
        -:  246:                    
        1:  247:                    printf("Restrição violada: Casa %c%d não está rodeada por %d vizinhas brancas.\n",
call    0 returned 1
        -:  248:                           coluna, linha, vizinhas);
        -:  249:                    
        -:  250:                }
        -:  251:            }
        -:  252:        }
        -:  253:    }
        6:  254:}
        -:  255:
        -:  256:
function verificar_brancas called 6 returned 100% blocks executed 100%
        6:  257:void verificar_brancas(char tabuleiro[26][1000], int linhas, int colunas) {
        -:  258:    // Verifica repetições em cada linha
       23:  259:    for (int i = 0; i < linhas; i++) {
branch  0 taken 17
branch  1 taken 6
       17:  260:        int contador[26] = {0};
        -:  261:
       63:  262:        for (int j = 0; j < colunas; j++) {
branch  0 taken 46
branch  1 taken 17
       46:  263:            if (isupper(tabuleiro[i][j])) {
branch  0 taken 25 (fallthrough)
branch  1 taken 21
       25:  264:                contador[tabuleiro[i][j] - 'A']++;
        -:  265:            }
        -:  266:        }
        -:  267:
      459:  268:        for (int k = 0; k < 26; k++) {
branch  0 taken 442
branch  1 taken 17 (fallthrough)
      442:  269:            if (contador[k] > 1) {
branch  0 taken 2 (fallthrough)
branch  1 taken 440
        2:  270:                char letra = 'A' + k;
        2:  271:                int linha_visual = i + 1;  
        2:  272:                printf("Restrição violada: Letra %c foi repetida %d vezes na linha %d.\n",
call    0 returned 2
        -:  273:                       letra, contador[k], linha_visual);
        -:  274:            }
        -:  275:        }
        -:  276:    }
        -:  277:    // Verifica repetições em cada coluna
       22:  278:    for (int j = 0; j < colunas; j++) {
branch  0 taken 16
branch  1 taken 6 (fallthrough)
       16:  279:        int contador[26] = {0};
       62:  280:        for (int i = 0; i < linhas; i++) {
branch  0 taken 46
branch  1 taken 16
       46:  281:            if (isupper(tabuleiro[i][j])) {
branch  0 taken 25 (fallthrough)
branch  1 taken 21
       25:  282:                contador[tabuleiro[i][j] - 'A']++;
        -:  283:            }
        -:  284:        }
        -:  285:
      432:  286:        for (int k = 0; k < 26; k++) {
branch  0 taken 416
branch  1 taken 16 (fallthrough)
      416:  287:            if (contador[k] > 1) {
branch  0 taken 2 (fallthrough)
branch  1 taken 414
        2:  288:                char letra = 'A' + k;
        2:  289:                char coluna_letra = 'a' + j; 
        2:  290:                printf("Restrição violada: Letra %c foi repetida %d vezes na coluna %c.\n",
call    0 returned 2
        -:  291:                       letra, contador[k], coluna_letra);
        -:  292:            }
        -:  293:        }
        -:  294:    }
        6:  295:}
        -:  296:
        -:  297:// Funções de interface
function imprimir_comandos called 1 returned 100% blocks executed 100%
        1:  298:void imprimir_comandos() {
        1:  299:    printf("Comandos disponíveis:\n");
call    0 returned 1
        1:  300:    printf("g - Gravar o jogo atual no ficheiro\n");
call    0 returned 1
        1:  301:    printf("l - Ler o estado do jogo num ficheiro\n");
call    0 returned 1
        1:  302:    printf("b letra nr - Pintar de branco\n");
call    0 returned 1
        1:  303:    printf("r letra nr - Riscar\n");
call    0 returned 1
        1:  304:    printf("v - Verificar restrições\n");
call    0 returned 1
        1:  305:    printf("a - Aplicar inferências\n");
call    0 returned 1
        1:  306:    printf("A - Repetir inferências até não haver mudanças\n");
call    0 returned 1
        1:  307:    printf("R - Resolver o jogo\n");
call    0 returned 1
        1:  308:    printf("d - Desfazer última ação\n");
call    0 returned 1
        1:  309:    printf("s - Sair\n");
call    0 returned 1
        1:  310:}
        -:  311:
        -:  312:// Função auxiliar: verifica se posição é válida
function dentro called 12 returned 100% blocks executed 100%
       12:  313:static bool dentro(int i, int j, int L, int C) {
       12:  314:    return i >= 0 && i < L && j >= 0 && j < C;
branch  0 taken 9 (fallthrough)
branch  1 taken 3
branch  2 taken 3 (fallthrough)
branch  3 taken 6
        -:  315:}
        -:  316:
function verificar_conectividade called 3 returned 100% blocks executed 94%
        3:  317:void verificar_conectividade(char tabuleiro[26][1000], int L, int C) {
        3:  318:    bool visitada[26][1000] = {false};
        3:  319:    int total_brancas = 0;
        3:  320:    int start_i = -1, start_j = -1;
        -:  321:
        -:  322:    // Conta casas brancas (maiúsculas) e encontra uma inicial
       12:  323:    for (int i = 0; i < L; i++) {
branch  0 taken 9
branch  1 taken 3 (fallthrough)
       36:  324:        for (int j = 0; j < C; j++) {
branch  0 taken 27
branch  1 taken 9 (fallthrough)
       27:  325:            if (isupper((unsigned char)tabuleiro[i][j])) {
branch  0 taken 12 (fallthrough)
branch  1 taken 15
       12:  326:                total_brancas++;
       12:  327:                if (start_i < 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 9
        3:  328:                    start_i = i;
        3:  329:                    start_j = j;
        -:  330:                }
        -:  331:            }
        -:  332:        }
        -:  333:    }
        3:  334:    if (total_brancas <= 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:  335:        // Menos de 2 casas brancas, nada a verificar
    #####:  336:        return;
        -:  337:    }
        -:  338:
        -:  339:    // BFS apenas através de casas brancas (maiúsculas)
        3:  340:    int *fila = malloc(sizeof(int) * L * C * 2);
        3:  341:    int frente = 0, tras = 0;
        3:  342:    fila[tras++] = start_i;
        3:  343:    fila[tras++] = start_j;
        3:  344:    int cont_visitadas = 0;
        -:  345:
        6:  346:    while (frente < tras) {
branch  0 taken 3
branch  1 taken 3 (fallthrough)
        3:  347:        int i = fila[frente++];
        3:  348:        int j = fila[frente++];
        3:  349:        if (!visitada[i][j] && isupper((unsigned char)tabuleiro[i][j])) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:  350:            visitada[i][j] = true;
        3:  351:            cont_visitadas++;
        -:  352:            // Vizinhança ortogonal
        3:  353:            const int di[4] = {-1, 1, 0, 0};
        3:  354:            const int dj[4] = {0, 0, -1, 1};
       15:  355:            for (int d = 0; d < 4; d++) {
branch  0 taken 12
branch  1 taken 3 (fallthrough)
       12:  356:                int ni = i + di[d];
       12:  357:                int nj = j + dj[d];
       12:  358:                if (dentro(ni, nj, L, C) && !visitada[ni][nj] && isupper((unsigned char)tabuleiro[ni][nj])) {
branch  0 taken 6 (fallthrough)
branch  1 taken 6
branch  2 taken 6 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 6
    #####:  359:                    fila[tras++] = ni;
    #####:  360:                    fila[tras++] = nj;
        -:  361:                }
        -:  362:            }
        -:  363:        }
        -:  364:    }
        3:  365:    free(fila);
        -:  366:
        -:  367:    // Verifica se todas as brancas foram visitadas
        3:  368:    if (cont_visitadas < total_brancas) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  369:        printf("Restrição violada: há casas brancas isoladas no tabuleiro.\n");
call    0 returned 3
       12:  370:        for (int i = 0; i < L; i++) {
call    0 returned 3
branch  1 taken 9
branch  2 taken 3 (fallthrough)
       36:  371:            for (int j = 0; j < C; j++) {
branch  0 taken 27
branch  1 taken 9 (fallthrough)
       27:  372:                if (isupper((unsigned char)tabuleiro[i][j]) && !visitada[i][j]) {
branch  0 taken 12 (fallthrough)
branch  1 taken 15
branch  2 taken 9 (fallthrough)
branch  3 taken 3
        9:  373:                    char col = 'a' + j;
        9:  374:                    int lin = i + 1;
        9:  375:                    printf("  Casa %c%d não está acessível.\n", col, lin);
call    0 returned 9
        -:  376:                }
        -:  377:            }
        -:  378:        }
        -:  379:    }
        -:  380:}
        -:  381:
        -:  382:// Alteração em verificar_estado para chamar a conectividade
function verificar_estado called 2 returned 100% blocks executed 100%
        2:  383:void verificar_estado(char tabuleiro[26][1000], int linhas, int colunas) {
        2:  384:    printf("Verificando restrições...\n");
call    0 returned 2
        2:  385:    verificar_riscadas(tabuleiro, linhas, colunas);
call    0 returned 2
        2:  386:    verificar_brancas(tabuleiro, linhas, colunas);
call    0 returned 2
        2:  387:    verificar_conectividade(tabuleiro, linhas, colunas);  // Etapa 3
call    0 returned 2
        2:  388:    printf("Verificação concluída.\n");
call    0 returned 2
        2:  389:}
        -:  390:
        -:  391:// Função auxiliar de conectividade usada pela Regra 3 permanece igual...
function conexao_valida_apos_risco called 5 returned 100% blocks executed 100%
        5:  392:static bool conexao_valida_apos_risco(Tabuleiro *orig, int ri, int rj) {
        5:  393:    Tabuleiro tmp = *orig;
        5:  394:    tmp.tabuleiro[ri][rj] = '#';
        5:  395:    bool visitada[26][1000] = {false};
        5:  396:    int total = 0, start_i = -1, start_j = -1;
       20:  397:    for (int i = 0; i < tmp.linhas; i++)
branch  0 taken 15
branch  1 taken 5 (fallthrough)
       60:  398:        for (int j = 0; j < tmp.colunas; j++)
branch  0 taken 45
branch  1 taken 15 (fallthrough)
       45:  399:            if (tmp.tabuleiro[i][j] != '#') {
branch  0 taken 33 (fallthrough)
branch  1 taken 12
       33:  400:                total++;
       33:  401:                if (start_i < 0) { start_i = i; start_j = j; }
branch  0 taken 5 (fallthrough)
branch  1 taken 28
        -:  402:            }
        5:  403:    if (total == 0) return true;
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:  404:
        5:  405:    int fila[26*1000][2];
        5:  406:    int f = 0, r = 0, cont = 0;
        5:  407:    fila[r][0] = start_i; fila[r][1] = start_j; r++;
        5:  408:    const int di[4] = {-1,1,0,0}, dj[4] = {0,0,-1,1};
       38:  409:    while (f < r) {
branch  0 taken 33
branch  1 taken 5 (fallthrough)
       33:  410:        int i = fila[f][0], j = fila[f][1]; f++;
       33:  411:        if (!visitada[i][j] && tmp.tabuleiro[i][j] != '#') {
branch  0 taken 28 (fallthrough)
branch  1 taken 5
branch  2 taken 28 (fallthrough)
branch  3 taken 0
       28:  412:            visitada[i][j] = true; cont++;
      140:  413:            for (int d = 0; d < 4; d++) {
branch  0 taken 112
branch  1 taken 28 (fallthrough)
      112:  414:                int ni = i + di[d], nj = j + dj[d];
      112:  415:                if (ni >= 0 && ni < tmp.linhas && nj >= 0 && nj < tmp.colunas
branch  0 taken 100 (fallthrough)
branch  1 taken 12
branch  2 taken 91 (fallthrough)
branch  3 taken 9
branch  4 taken 85 (fallthrough)
branch  5 taken 6
branch  6 taken 73 (fallthrough)
branch  7 taken 12
       73:  416:                    && !visitada[ni][nj] && tmp.tabuleiro[ni][nj] != '#') {
branch  0 taken 45 (fallthrough)
branch  1 taken 28
branch  2 taken 28 (fallthrough)
branch  3 taken 17
       28:  417:                    fila[r][0] = ni; fila[r][1] = nj; r++;
        -:  418:                }
        -:  419:            }
        -:  420:        }
        -:  421:    }
        5:  422:    return cont == total;
        -:  423:}
        -:  424:
        -:  425:// Aplica uma única vez as três regras de inferência (comando 'a'), usando sempre o tabuleiro original
function aplicar_correcoes called 2 returned 100% blocks executed 96%
        2:  426:void aplicar_correcoes(Tabuleiro *t) {
        2:  427:    Tabuleiro orig = *t;
        2:  428:    int alteracoes = 0;
        -:  429:
        -:  430:    // Buffer para novo estado
        2:  431:    char novo[26][1000];
        8:  432:    for (int i = 0; i < orig.linhas; i++)
branch  0 taken 6
branch  1 taken 2
       24:  433:        for (int j = 0; j < orig.colunas; j++)
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  434:            novo[i][j] = orig.tabuleiro[i][j];
        -:  435:
        -:  436:    // Regra 1: riscar em 'novo' minúsculas de cada branca em 'orig'
        8:  437:    for (int i = 0; i < orig.linhas; i++) {
branch  0 taken 6
branch  1 taken 2 (fallthrough)
       24:  438:        for (int j = 0; j < orig.colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  439:            if (isupper((unsigned char)orig.tabuleiro[i][j])) {
branch  0 taken 6 (fallthrough)
branch  1 taken 12
        6:  440:                char c = tolower(orig.tabuleiro[i][j]);
       24:  441:                for (int col = 0; col < orig.colunas; col++) {
branch  0 taken 18
branch  1 taken 6
       18:  442:                    if (orig.tabuleiro[i][col] == c && novo[i][col] != '#') {
branch  0 taken 1 (fallthrough)
branch  1 taken 17
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  443:                        novo[i][col] = '#'; alteracoes++;
        -:  444:                    }
        -:  445:                }
       24:  446:                for (int lin = 0; lin < orig.linhas; lin++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
      18*:  447:                    if (orig.tabuleiro[lin][j] == c && novo[lin][j] != '#') {
branch  0 taken 0 (fallthrough)
branch  1 taken 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  448:                        novo[lin][j] = '#'; alteracoes++;
        -:  449:                    }
        -:  450:                }
        -:  451:            }
        -:  452:        }
        -:  453:    }
        -:  454:
        -:  455:    // Regra 2: pintar vizinhos de '#' em 'orig'
        2:  456:    const int di[4] = {-1,1,0,0}, dj[4] = {0,0,-1,1};
        8:  457:    for (int i = 0; i < orig.linhas; i++) {
branch  0 taken 6
branch  1 taken 2
       24:  458:        for (int j = 0; j < orig.colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  459:            if (orig.tabuleiro[i][j] == '#') {
branch  0 taken 4
branch  1 taken 14
       20:  460:                for (int d = 0; d < 4; d++) {
branch  0 taken 16
branch  1 taken 4 (fallthrough)
       16:  461:                    int ni = i + di[d], nj = j + dj[d];
       16:  462:                    if (ni >= 0 && ni < orig.linhas && nj >= 0 && nj < orig.colunas
branch  0 taken 14 (fallthrough)
branch  1 taken 2
branch  2 taken 14 (fallthrough)
branch  3 taken 0
branch  4 taken 12 (fallthrough)
branch  5 taken 2
branch  6 taken 11 (fallthrough)
branch  7 taken 1
       11:  463:                        && islower((unsigned char)orig.tabuleiro[ni][nj])
branch  0 taken 5 (fallthrough)
branch  1 taken 6
        5:  464:                        && novo[ni][nj] != toupper((unsigned char)orig.tabuleiro[ni][nj])) {
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4:  465:                        novo[ni][nj] = toupper((unsigned char)orig.tabuleiro[ni][nj]);
        4:  466:                        alteracoes++;
        -:  467:                    }
        -:  468:                }
        -:  469:            }
        -:  470:        }
        -:  471:    }
        -:  472:
        -:  473:    // Regra 3: evitar isolamento de brancas — usar conexão completa simulada
        8:  474:    for (int i = 0; i < orig.linhas; i++) {
branch  0 taken 6
branch  1 taken 2
       24:  475:        for (int j = 0; j < orig.colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  476:            if (islower((unsigned char)orig.tabuleiro[i][j])) {
branch  0 taken 5 (fallthrough)
branch  1 taken 13
        5:  477:                if (!conexao_valida_apos_risco(&orig, i, j)) {
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2:  478:                    char mai = toupper((unsigned char)orig.tabuleiro[i][j]);
        2:  479:                    if (novo[i][j] != mai) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  480:                        novo[i][j] = mai; alteracoes++;
        -:  481:                    }
        -:  482:                }
        -:  483:            }
        -:  484:        }
        -:  485:    }
        -:  486:
        -:  487:    // Copia 'novo' para o tabuleiro
        8:  488:    for (int i = 0; i < orig.linhas; i++)
branch  0 taken 6
branch  1 taken 2 (fallthrough)
       24:  489:        for (int j = 0; j < orig.colunas; j++)
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  490:            t->tabuleiro[i][j] = novo[i][j];
        -:  491:
        2:  492:    printf("Alterações aplicadas: %d\n", alteracoes);
call    0 returned 2
        2:  493:}
        -:  494:
function resolve_jogo called 1 returned 100% blocks executed 90%
        1:  495:int resolve_jogo(Tabuleiro *t) {
        1:  496:    int alterado;
        1:  497:    int total_mudou = 0;
        -:  498:
        2:  499:    do {
        2:  500:        alterado = 0;
        -:  501:
        8:  502:        for (int i = 0; i < t->linhas; i++) {
branch  0 taken 6
branch  1 taken 2 (fallthrough)
       24:  503:            for (int j = 0; j < t->colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  504:                char atual = t->tabuleiro[i][j];
        -:  505:
        -:  506:                // Regra 1: riscar repetidos de brancas (considerando maiúsculas e suas versões minúsculas)
       18:  507:                if (isupper((unsigned char)atual)) {
branch  0 taken 5
branch  1 taken 13
       20:  508:                    for (int k = 0; k < t->colunas; k++) {
branch  0 taken 15
branch  1 taken 5
       15:  509:                        if (k != j && (t->tabuleiro[i][k] == atual || t->tabuleiro[i][k] == tolower(atual))) {
branch  0 taken 10 (fallthrough)
branch  1 taken 5
branch  2 taken 10 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 10
    #####:  510:                            t->tabuleiro[i][k] = '#';
    #####:  511:                            alterado = 1;
        -:  512:                        }
        -:  513:                    }
       20:  514:                    for (int k = 0; k < t->linhas; k++) {
branch  0 taken 15
branch  1 taken 5 (fallthrough)
       15:  515:                        if (k != i && (t->tabuleiro[k][j] == atual || t->tabuleiro[k][j] == tolower(atual))) {
branch  0 taken 10 (fallthrough)
branch  1 taken 5
branch  2 taken 10 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 10
    #####:  516:                            t->tabuleiro[k][j] = '#';
    #####:  517:                            alterado = 1;
        -:  518:                        }
        -:  519:                    }
        -:  520:                }
        -:  521:
        -:  522:                // Regra 2: vizinhos de # viram brancos
       18:  523:                if (t->tabuleiro[i][j] == '#') {
branch  0 taken 0 (fallthrough)
branch  1 taken 18
    #####:  524:                    alterado |= pintar_vizinhos_de_branco(t, i, j);
call    0 never executed
        -:  525:                }
        -:  526:
        -:  527:                // Regra 3: se riscar isolaria, pintar de branco
       18:  528:                if (islower((unsigned char)atual)) {
branch  0 taken 13 (fallthrough)
branch  1 taken 5
       13:  529:                    int pode_riscar = 0;
       13:  530:                    if (i > 0 && isupper((unsigned char)t->tabuleiro[i - 1][j])) pode_riscar = 1;
branch  0 taken 9 (fallthrough)
branch  1 taken 4
branch  2 taken 6 (fallthrough)
branch  3 taken 3
       13:  531:                    if (i < t->linhas - 1 && isupper((unsigned char)t->tabuleiro[i + 1][j])) pode_riscar = 1;
branch  0 taken 9 (fallthrough)
branch  1 taken 4
branch  2 taken 3 (fallthrough)
branch  3 taken 6
       13:  532:                    if (j > 0 && isupper((unsigned char)t->tabuleiro[i][j - 1])) pode_riscar = 1;
branch  0 taken 9 (fallthrough)
branch  1 taken 4
branch  2 taken 6 (fallthrough)
branch  3 taken 3
       13:  533:                    if (j < t->colunas - 1 && isupper((unsigned char)t->tabuleiro[i][j + 1])) pode_riscar = 1;
branch  0 taken 9 (fallthrough)
branch  1 taken 4
branch  2 taken 6 (fallthrough)
branch  3 taken 3
        -:  534:
       10:  535:                    if (!pode_riscar) {
branch  0 taken 5 (fallthrough)
branch  1 taken 5
        5:  536:                        t->tabuleiro[i][j] = toupper((unsigned char)atual);
        5:  537:                        alterado = 1;
        -:  538:                    }
        -:  539:                }
        -:  540:            }
        -:  541:        }
        -:  542:
        2:  543:        if (alterado) total_mudou = 1;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:  544:
        2:  545:    } while (alterado);
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -:  546:
        1:  547:    return total_mudou;
        -:  548:}
