        -:    0:Source:projeto.c
        -:    0:Graph:teste_cov-projeto.gcno
        -:    0:Data:teste_cov-projeto.gcda
        -:    0:Runs:1
        -:    1:#include "projeto.h"
        -:    2:#include <stdio.h>
        -:    3:#include <ctype.h>
        -:    4:#include <string.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <stdbool.h>
        -:    7:
        -:    8:// Declaração do array de estados e topo da stack
        -:    9:Tabuleiro stack[tamanhoStack];  // Guarda os estados anteriores do tabuleiro
        -:   10:int topoStack = -1;             // Índice do topo da stack (inicialmente vazio)
        -:   11:
function formatoParaCoordenadas called 13 returned 100% blocks executed 100%
       13:   12:int formatoParaCoordenadas(char *input, int *x, int *y) {
       13:   13:    if (input == NULL || strlen(input) < 2) return 0;
branch  0 taken 12 (fallthrough)
branch  1 taken 1
branch  2 taken 10 (fallthrough)
branch  3 taken 2
        -:   14:
       10:   15:    if (!isalpha(input[0])) return 0;
branch  0 taken 7 (fallthrough)
branch  1 taken 3
        -:   16:
        -:   17:    // Converte letra para índice de linha, aceita maiúsculas e minúsculas
        7:   18:    *x = tolower(input[0]) - 'a';
        -:   19:
        -:   20:    // Verifica se o resto é só número (sem caracteres extras)
        7:   21:    char *ponteirofim;
        7:   22:    long numero = strtol(input + 1, &ponteirofim, 10);
call    0 returned 7
        -:   23:
        7:   24:    if (*ponteirofim != '\0') return 0;  // Há caracteres a mais após o número
branch  0 taken 4 (fallthrough)
branch  1 taken 3
        4:   25:    if (numero < 1) return 0;       // Número deve ser positivo
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -:   26:
        4:   27:    *y = (int)numero - 1;
        4:   28:    return 1;
        -:   29:}
        -:   30:
function imprimirTabuleiro called 3 returned 100% blocks executed 100%
        3:   31:void imprimirTabuleiro(char tabuleiro[26][1000], int linhas, int colunas) {
       12:   32:    for (int i = 0; i < linhas; i++) {
branch  0 taken 9 (fallthrough)
branch  1 taken 3
       36:   33:        for (int j = 0; j < colunas; j++) {
branch  0 taken 27
branch  1 taken 9 (fallthrough)
       27:   34:            printf("%c ", tabuleiro[i][j]);
call    0 returned 27
        -:   35:        }
        9:   36:        printf("\n");
call    0 returned 9
        -:   37:    }
        3:   38:}
        -:   39:
function pintarDeBranco called 5 returned 100% blocks executed 100%
        5:   40:void pintarDeBranco(char tabuleiro[26][1000], int linhas, int colunas, int x, int y) {
        5:   41:    if (y >= 0 && y < linhas && x >= 0 && x < colunas) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:   42:        tabuleiro[y][x] = toupper(tabuleiro[y][x]);
        -:   43:    } else {
        2:   44:        printf("Coordenada fora dos limites.\n");
call    0 returned 2
        -:   45:    }
        5:   46:}
        -:   47:
function riscar called 5 returned 100% blocks executed 100%
        5:   48:void riscar(char tabuleiro[26][1000], int linhas, int colunas, int x, int y) {
        5:   49:    if (y >= 0 && y < linhas && x >= 0 && x < colunas) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:   50:        if (tabuleiro[y][x] != '\0') {
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:   51:            tabuleiro[y][x] = '#';
        -:   52:        } else {
        1:   53:            printf("Célula vazia, não pode ser riscada.\n");
call    0 returned 1
        -:   54:        }
        -:   55:    } else {
        2:   56:        printf("Coordenada fora dos limites.\n");
call    0 returned 2
        -:   57:    }
        5:   58:}
        -:   59:
        -:   60:// Função para transformar casas vizinhas de riscas em brancas, retornando se houve mudança
function pintar_vizinhos_de_branco called 1 returned 100% blocks executed 100%
        1:   61:int pintar_vizinhos_de_branco(Tabuleiro *t, int i, int j) {
        1:   62:    int alterado = 0;
        1:   63:    int dx[] = {-1, 1, 0, 0};
        1:   64:    int dy[] = {0, 0, -1, 1};
        -:   65:
        5:   66:    for (int d = 0; d < 4; d++) {
branch  0 taken 4
branch  1 taken 1 (fallthrough)
        4:   67:        int ni = i + dx[d];
        4:   68:        int nj = j + dy[d];
        -:   69:
        4:   70:        if (ni >= 0 && ni < t->linhas && nj >= 0 && nj < t->colunas) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
branch  2 taken 4 (fallthrough)
branch  3 taken 0
branch  4 taken 4 (fallthrough)
branch  5 taken 0
branch  6 taken 4 (fallthrough)
branch  7 taken 0
        4:   71:            char c = t->tabuleiro[ni][nj];
        4:   72:            if (islower((char)c)) {
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:   73:                t->tabuleiro[ni][nj] = toupper((char)c);
        2:   74:                alterado = 1;
        -:   75:            }
        -:   76:        }
        -:   77:    }
        -:   78:
        1:   79:    return alterado;
        -:   80:}
        -:   81:
        -:   82:// Função que empilha um estado do tabuleiro
function stacks called 105 returned 100% blocks executed 100%
      105:   83:void stacks(Tabuleiro estado) {
      105:   84:    if (topoStack < tamanhoStack - 1) {      // Verifica se há espaço na stack
branch  0 taken 104 (fallthrough)
branch  1 taken 1
      104:   85:        topoStack++;                         // Avança o topo
      104:   86:        stack[topoStack] = estado;           // Guarda o novo estado
        -:   87:    } else {
        1:   88:        printf("Stack cheia. Não é possível guardar mais estados.\n");
call    0 returned 1
        -:   89:    }
      105:   90:}
        -:   91:
        -:   92:// Função que retira o último estado guardado (desfazer)
function desempilhar called 5 returned 100% blocks executed 100%
        5:   93:Tabuleiro desempilhar() {
        5:   94:    if (topoStack >= 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:   95:        return stack[topoStack--];           // Retorna e remove o topo da stack
        -:   96:    } else {
        2:   97:        printf("Stack vazia.\n");
call    0 returned 2
        2:   98:        Tabuleiro vazio = {{{0}}, 0, 0};     // Retorna tabuleiro vazio em caso de erro
        2:   99:        return vazio;
        -:  100:    }
        -:  101:}
        -:  102:
        -:  103:// Função que guarda o estado atual do tabuleiro na stack
function guardar_estado called 101 returned 100% blocks executed 100%
      101:  104:void guardar_estado(Tabuleiro *t) {
      101:  105:    stacks(*t);  // Copia o estado atual para a stack
call    0 returned 101
      101:  106:}
        -:  107:
        -:  108:
        -:  109:// Função que desfaz a última ação, restaurando o tabuleiro anterior
function desfazer called 2 returned 100% blocks executed 100%
        2:  110:void desfazer(Tabuleiro *t) {
        2:  111:    Tabuleiro tabuleiroAnterior = desempilhar();  // Recupera o estado anterior
call    0 returned 2
        -:  112:
        -:  113:    // Só substitui se o estado desempilhado for válido
        2:  114:    if (tabuleiroAnterior.linhas > 0 && tabuleiroAnterior.colunas > 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  115:        *t = tabuleiroAnterior;
        -:  116:    } else {
        1:  117:        printf("Não é possível desfazer mais ações.\n");
call    0 returned 1
        -:  118:    }
        2:  119:}
        -:  120:
        -:  121:
        -:  122:// Grava a stack de estados num ficheiro
function gravarStack called 3 returned 100% blocks executed 100%
        3:  123:void gravarStack(char *nome) {
        3:  124:    FILE *f = fopen(nome, "w");
call    0 returned 3
        3:  125:    if (!f) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  126:        perror("Erro ao guardar a stack");
        1:  127:        return;
call    0 returned 1
        -:  128:    }
        -:  129:
        2:  130:    fprintf(f, "%d\n", topoStack);  // Escreve topo da stack
call    0 returned 2
        -:  131:
        -:  132:    // Escreve cada estado da stack
        3:  133:    for (int i = 0; i <= topoStack; i++) {
call    0 returned 2
branch  1 taken 1
branch  2 taken 2 (fallthrough)
        1:  134:        fprintf(f, "%d %d\n", stack[i].linhas, stack[i].colunas);
call    0 returned 1
        3:  135:        for (int y = 0; y < stack[i].linhas; y++) {
call    0 returned 1
branch  1 taken 2
branch  2 taken 1 (fallthrough)
        6:  136:            for (int x = 0; x < stack[i].colunas; x++) {
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  137:                fputc(stack[i].tabuleiro[y][x], f);
call    0 returned 4
        -:  138:            }
        2:  139:            fputc('\n', f);
call    0 returned 2
        -:  140:        }
        -:  141:    }
        -:  142:
        2:  143:    fclose(f);
call    0 returned 2
        -:  144:}
        -:  145:
        -:  146:// Grava o estado atual do jogo e a stack
function gravarJogo called 2 returned 100% blocks executed 100%
        2:  147:void gravarJogo(char *nome, Tabuleiro *t) {
        2:  148:    FILE *arquivo = fopen(nome, "w");
call    0 returned 2
        2:  149:    if (arquivo == NULL) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  150:        perror("Erro ao abrir tabuleiro.txt");
        1:  151:        return;
call    0 returned 1
        -:  152:    }
        -:  153:
        1:  154:    fprintf(arquivo, "%d %d\n", t->colunas, t->linhas);  // Grava dimensões
call    0 returned 1
        -:  155:
        -:  156:    // Grava tabuleiro linha por linha
        3:  157:    for (int i = 0; i < t->linhas; i++) {
call    0 returned 1
branch  1 taken 2
branch  2 taken 1 (fallthrough)
        6:  158:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  159:            fputc(t->tabuleiro[i][j], arquivo);
call    0 returned 4
        -:  160:        }
        2:  161:        fputc('\n', arquivo);
call    0 returned 2
        -:  162:    }
        -:  163:
        1:  164:    fclose(arquivo);
call    0 returned 1
        -:  165:
        -:  166:    // Também grava a stack
        1:  167:    gravarStack("stack.txt");
call    0 returned 1
        -:  168:}
        -:  169:
        -:  170:
        -:  171:// Lê o histórico da stack de um ficheiro
function lerStack called 4 returned 100% blocks executed 100%
        4:  172:void lerStack(char *nome) {
        4:  173:    FILE *f = fopen(nome, "r");
call    0 returned 4
        4:  174:    if (!f) {
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  175:        topoStack = -1;
        1:  176:        return;
        -:  177:    }
        -:  178:
        -:  179:    // Lê o topo
        3:  180:    if (fscanf(f, "%d\n", &topoStack) != 1) {
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1:  181:        fclose(f);
call    0 returned 1
        1:  182:        topoStack = -1;
        1:  183:        return;
        -:  184:    }
        -:  185:
        -:  186:    // Lê os estados
        3:  187:    for (int i = 0; i <= topoStack; i++) {
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2:  188:        if (fscanf(f, "%d %d\n", &stack[i].linhas, &stack[i].colunas) != 2) {
call    0 returned 2
branch  1 taken 1 (fallthrough)
branch  2 taken 1
        1:  189:            topoStack = i - 1;
        1:  190:            break;
        -:  191:        }
        -:  192:
        3:  193:        for (int y = 0; y < stack[i].linhas; y++) {
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        6:  194:            for (int x = 0; x < stack[i].colunas; x++) {
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  195:                stack[i].tabuleiro[y][x] = fgetc(f);
call    0 returned 4
        -:  196:            }
        2:  197:            fgetc(f); // Salta '\n'
call    0 returned 2
        -:  198:        }
        -:  199:    }
        -:  200:
        2:  201:    fclose(f);
call    0 returned 2
        -:  202:}
        -:  203:
        -:  204:
        -:  205:// Lê o estado atual do tabuleiro de um ficheiro
function lerJogo called 6 returned 100% blocks executed 87%
        6:  206:void lerJogo(char *nome, Tabuleiro *t) {
        6:  207:    FILE *f = fopen(nome, "r");
call    0 returned 6
        6:  208:    if (!f) {
branch  0 taken 2 (fallthrough)
branch  1 taken 4
        2:  209:        printf("Erro ao abrir ficheiro: %s\n", nome);
call    0 returned 2
        2:  210:        return;
call    0 returned 2
        -:  211:    }
        -:  212:
        -:  213:    // Lê dimensões
        4:  214:    if (fscanf(f, "%d %d", &t->linhas, &t->colunas) != 2) {
call    0 returned 4
branch  1 taken 2 (fallthrough)
branch  2 taken 2
        2:  215:        printf("Erro ao ler dimensões do tabuleiro.\n");
call    0 returned 2
        2:  216:        fclose(f);
        2:  217:        return;
call    0 returned 2
        -:  218:    }
        -:  219:
        2:  220:    fgetc(f);  // Consome '\n' após dimensões
        -:  221:
        -:  222:    // Lê o conteúdo do tabuleiro
        7:  223:    for (int i = 0; i < t->linhas; i++) {
call    0 returned 2
branch  1 taken 5
branch  2 taken 2 (fallthrough)
       18:  224:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 13
branch  1 taken 5 (fallthrough)
       13:  225:            char c = fgetc(f);
call    0 returned 13
       13:  226:            if (c == EOF) {
branch  0 taken 0 (fallthrough)
branch  1 taken 13
    #####:  227:                printf("Erro: Dados insuficientes no ficheiro.\n");
call    0 never executed
    #####:  228:                fclose(f);
    #####:  229:                return;
call    0 never executed
        -:  230:            }
       13:  231:            t->tabuleiro[i][j] = c;
        -:  232:        }
        5:  233:        fgetc(f); // Salta '\n'
call    0 returned 5
        -:  234:    }
        -:  235:
        2:  236:    fclose(f);
call    0 returned 2
        -:  237:}
        -:  238:
        -:  239:// Verifica se todas as casas riscadas estão rodeadas de brancas
function verificar_riscadas called 6 returned 100% blocks executed 100%
        6:  240:void verificar_riscadas(Tabuleiro *t) {
       23:  241:    for (int i = 0; i < t->linhas; i++) {
branch  0 taken 17
branch  1 taken 6 (fallthrough)
       66:  242:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 49
branch  1 taken 17 (fallthrough)
       49:  243:            if (t->tabuleiro[i][j] == '#') {  // Se for uma casa riscada
branch  0 taken 18 (fallthrough)
branch  1 taken 31
       18:  244:                int brancas = 0, vizinhas = 0;
        -:  245:
        -:  246:                // Cima
       18:  247:                if (i > 0) {
branch  0 taken 13 (fallthrough)
branch  1 taken 5
       13:  248:                    vizinhas++;
       13:  249:                    if (isupper(t->tabuleiro[i-1][j])) brancas++;
branch  0 taken 12 (fallthrough)
branch  1 taken 1
        -:  250:                }
        -:  251:                // Baixo
       18:  252:                if (i < t->linhas - 1) {
branch  0 taken 14 (fallthrough)
branch  1 taken 4
       14:  253:                    vizinhas++;
       14:  254:                    if (isupper(t->tabuleiro[i+1][j])) brancas++;
branch  0 taken 13 (fallthrough)
branch  1 taken 1
        -:  255:                }
        -:  256:                // Esquerda
       18:  257:                if (j > 0) {
branch  0 taken 13 (fallthrough)
branch  1 taken 5
       13:  258:                    vizinhas++;
       13:  259:                    if (isupper(t->tabuleiro[i][j-1])) brancas++;
branch  0 taken 12 (fallthrough)
branch  1 taken 1
        -:  260:                }
        -:  261:                // Direita
       18:  262:                if (j < t->colunas - 1) {
branch  0 taken 14 (fallthrough)
branch  1 taken 4
       14:  263:                    vizinhas++;
       14:  264:                    if (isupper(t->tabuleiro[i][j+1])) brancas++;
branch  0 taken 13 (fallthrough)
branch  1 taken 1
        -:  265:                }
        -:  266:
        -:  267:                // Regra: casa riscada deve estar rodeada por brancas
       18:  268:                if (brancas < vizinhas) {
branch  0 taken 1 (fallthrough)
branch  1 taken 17
        1:  269:                    char col = 'a' + j;
        1:  270:                    int lin = i + 1;
        1:  271:                    printf("Restrição violada: Casa %c%d não está rodeada por %d vizinhas brancas.\n",
call    0 returned 1
        -:  272:                           col, lin, vizinhas);
        -:  273:                }
        -:  274:            }
        -:  275:        }
        -:  276:    }
        6:  277:}
        -:  278:
        -:  279:// Verifica se há letras brancas repetidas em linhas e colunas
function verificar_brancas called 6 returned 100% blocks executed 100%
        6:  280:void verificar_brancas(Tabuleiro *t) {
        -:  281:    // Verifica por linha
       23:  282:    for (int i = 0; i < t->linhas; i++) {
branch  0 taken 17
branch  1 taken 6
       17:  283:        int cnt[26] = {0};
       60:  284:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 43
branch  1 taken 17
       43:  285:            char c = t->tabuleiro[i][j];
       43:  286:            if (isupper(c)) cnt[c - 'A']++;
branch  0 taken 25 (fallthrough)
branch  1 taken 18
        -:  287:        }
      459:  288:        for (int k = 0; k < 26; k++) {
branch  0 taken 442
branch  1 taken 17 (fallthrough)
      442:  289:            if (cnt[k] > 1) {
branch  0 taken 2 (fallthrough)
branch  1 taken 440
        2:  290:                printf("Restrição violada: Letra %c foi repetida %d vezes na linha %d.\n",
call    0 returned 2
        -:  291:                       'A' + k, cnt[k], i+1);
        -:  292:            }
        -:  293:        }
        -:  294:    }
        -:  295:
        -:  296:    // Verifica por coluna
       21:  297:    for (int j = 0; j < t->colunas; j++) {
branch  0 taken 15
branch  1 taken 6 (fallthrough)
       15:  298:        int cnt[26] = {0};
       58:  299:        for (int i = 0; i < t->linhas; i++) {
branch  0 taken 43
branch  1 taken 15
       43:  300:            char c = t->tabuleiro[i][j];
       43:  301:            if (isupper(c)) cnt[c - 'A']++;
branch  0 taken 25 (fallthrough)
branch  1 taken 18
        -:  302:        }
      405:  303:        for (int k = 0; k < 26; k++) {
branch  0 taken 390
branch  1 taken 15 (fallthrough)
      390:  304:            if (cnt[k] > 1) {
branch  0 taken 2 (fallthrough)
branch  1 taken 388
        2:  305:                printf("Restrição violada: Letra %c foi repetida %d vezes na coluna %c.\n",
call    0 returned 2
        -:  306:                       'A' + k, cnt[k], 'a' + j);
        -:  307:            }
        -:  308:        }
        -:  309:    }
        6:  310:}
        -:  311:
        -:  312:// Verifica se todas as casas brancas estão conectadas
function verificar_conectividade called 4 returned 100% blocks executed 100%
        4:  313:bool verificar_conectividade(Tabuleiro *t) {
        4:  314:    int L = t->linhas, C = t->colunas;
        4:  315:    bool visitado[26][1000];
        4:  316:    memset(visitado, 0, sizeof visitado);
        -:  317:
        4:  318:    int total_brancas = 0;
        4:  319:    int comeco_i = -1, comeco_j = -1;
        -:  320:
        -:  321:    // Procura todas as casas brancas e seleciona uma de partida
       16:  322:    for (int i = 0; i < L; i++) {
branch  0 taken 12
branch  1 taken 4 (fallthrough)
       48:  323:        for (int j = 0; j < C; j++) {
branch  0 taken 36
branch  1 taken 12 (fallthrough)
       36:  324:            if (isupper(t->tabuleiro[i][j])) {
branch  0 taken 21 (fallthrough)
branch  1 taken 15
       21:  325:                total_brancas++;
       21:  326:                if (comeco_i < 0) {
branch  0 taken 4 (fallthrough)
branch  1 taken 17
        4:  327:                    comeco_i = i;
        4:  328:                    comeco_j = j;
        -:  329:                }
        -:  330:            }
        -:  331:        }
        -:  332:    }
        -:  333:
        4:  334:    if (total_brancas <= 1) return true; // Conectividade trivial
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -:  335:
        -:  336:    // BFS a partir da casa branca inicial
        4:  337:    int fila_i[L*C], fila_j[L*C], frente = 0, atras = 0;
        4:  338:    fila_i[atras] = comeco_i;
        4:  339:    fila_j[atras++] = comeco_j;
        4:  340:    visitado[comeco_i][comeco_j] = true;
        4:  341:    int cont = 1;
        -:  342:
        4:  343:    int di[4] = {-1,1,0,0}, dj[4] = {0,0,-1,1};
       16:  344:    while (frente < atras) {
branch  0 taken 12
branch  1 taken 4 (fallthrough)
       12:  345:        int ci = fila_i[frente], cj = fila_j[frente++];
       60:  346:        for (int d = 0; d < 4; d++) {
branch  0 taken 48
branch  1 taken 12 (fallthrough)
       48:  347:            int ni = ci + di[d], nj = cj + dj[d];
       48:  348:            if (ni >= 0 && ni < L && nj >= 0 && nj < C &&
branch  0 taken 39 (fallthrough)
branch  1 taken 9
branch  2 taken 30 (fallthrough)
branch  3 taken 9
       30:  349:                isupper(t->tabuleiro[ni][nj]) && !visitado[ni][nj]) {
branch  0 taken 24 (fallthrough)
branch  1 taken 6
branch  2 taken 8 (fallthrough)
branch  3 taken 16
        8:  350:                visitado[ni][nj] = true;
        8:  351:                fila_i[atras] = ni;
        8:  352:                fila_j[atras++] = nj;
        8:  353:                cont++;
        -:  354:            }
        -:  355:        }
        -:  356:    }
        -:  357:
        -:  358:    // Se todas as casas brancas foram visitadas, estão conectadas
        4:  359:    return cont == total_brancas;
        -:  360:}
        -:  361:
        -:  362:// Função principal que junta todas as verificações de regras
function verificar_estado called 2 returned 100% blocks executed 100%
        2:  363:void verificar_estado(Tabuleiro *t) {
        2:  364:    printf("Verificando restrições...\n");
call    0 returned 2
        2:  365:    verificar_riscadas(t);         // Verifica casas riscadas
call    0 returned 2
        2:  366:    verificar_brancas(t);          // Verifica repetições de letras
call    0 returned 2
        2:  367:    if (!verificar_conectividade(t)) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2:  368:        printf("Restrição violada: há casas brancas isoladas no tabuleiro.\n");
call    0 returned 2
        -:  369:    }
        2:  370:    printf("Verificação concluída.\n");
call    0 returned 2
        2:  371:}
        -:  372:
        -:  373:
        -:  374:// Função auxiliar de conectividade usada pela Regra 3 permanece igual...
function conexao_valida_apos_risco called 5 returned 100% blocks executed 100%
        5:  375:bool conexao_valida_apos_risco(Tabuleiro *orig, int ri, int rj) {
        -:  376:    // 1) Faz a cópia e aplica o risco
        5:  377:    Tabuleiro tmp = *orig;
        5:  378:    tmp.tabuleiro[ri][rj] = '#';
        -:  379:
        -:  380:    // 2) Inicializa visitada
        5:  381:    bool visitada[26][1000];
        5:  382:    memset(visitada, 0, sizeof visitada);
        -:  383:
        -:  384:    // 3) Conta apenas as casas brancas (maiúsculas) e escolhe ponto de partida
        5:  385:    int total = 0, start_i = -1, start_j = -1;
       20:  386:    for (int i = 0; i < tmp.linhas; i++) {
branch  0 taken 15
branch  1 taken 5 (fallthrough)
       60:  387:      for (int j = 0; j < tmp.colunas; j++) {
branch  0 taken 45
branch  1 taken 15 (fallthrough)
       45:  388:        if (isupper((char)tmp.tabuleiro[i][j])) {
branch  0 taken 18 (fallthrough)
branch  1 taken 27
       18:  389:          total++;
       18:  390:          if (start_i < 0) {
branch  0 taken 5 (fallthrough)
branch  1 taken 13
        5:  391:            start_i = i; start_j = j;
        -:  392:          }
        -:  393:        }
        -:  394:      }
        -:  395:    }
        -:  396:
        -:  397:    // Se não houver ou houver só uma branca, conectividade é trivial
        5:  398:    if (total <= 1) return true;
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -:  399:
        -:  400:    // 4) BFS só sobre as casas brancas
        5:  401:    int maxq = tmp.linhas * tmp.colunas;
        5:  402:    int fila_i[maxq], fila_j[maxq];
        5:  403:    int front = 0, back = 0;
        5:  404:    fila_i[back] = start_i;
        5:  405:    fila_j[back++] = start_j;
        5:  406:    visitada[start_i][start_j] = true;
        5:  407:    int cont = 1;
        -:  408:
        5:  409:    int di[4] = {-1,1,0,0}, dj[4] = {0,0,-1,1};
       22:  410:    while (front < back) {
branch  0 taken 17
branch  1 taken 5 (fallthrough)
       17:  411:        int ci = fila_i[front], cj = fila_j[front++];
       85:  412:        for (int d = 0; d < 4; d++) {
branch  0 taken 68
branch  1 taken 17 (fallthrough)
       68:  413:            int ni = ci + di[d], nj = cj + dj[d];
       68:  414:            if (ni >= 0 && ni < tmp.linhas && nj >= 0 && nj < tmp.colunas
branch  0 taken 59 (fallthrough)
branch  1 taken 9
branch  2 taken 55 (fallthrough)
branch  3 taken 4
branch  4 taken 54 (fallthrough)
branch  5 taken 1
branch  6 taken 42 (fallthrough)
branch  7 taken 12
       42:  415:             && isupper((char)tmp.tabuleiro[ni][nj])
branch  0 taken 24 (fallthrough)
branch  1 taken 18
       24:  416:             && !visitada[ni][nj]) {
branch  0 taken 12 (fallthrough)
branch  1 taken 12
       12:  417:                visitada[ni][nj] = true;
       12:  418:                fila_i[back] = ni;
       12:  419:                fila_j[back++] = nj;
       12:  420:                cont++;
        -:  421:            }
        -:  422:        }
        -:  423:    }
        -:  424:
        -:  425:    // 5) Só devolve true se visitou todas as brancas
        5:  426:    return cont == total;
        -:  427:}
        -:  428:
        -:  429:
        -:  430:// Aplica uma única vez as três regras de inferência (comando 'a'), usando sempre o tabuleiro original
function aplicar_correcoes called 2 returned 100% blocks executed 94%
        2:  431:void aplicar_correcoes(Tabuleiro *t) {
        2:  432:    Tabuleiro orig = *t;
        2:  433:    int alteracoes = 0;
        -:  434:
        -:  435:    // Buffer para novo estado
        2:  436:    char novo[26][1000];
        8:  437:    for (int i = 0; i < orig.linhas; i++)
branch  0 taken 6
branch  1 taken 2
       24:  438:        for (int j = 0; j < orig.colunas; j++)
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  439:            novo[i][j] = orig.tabuleiro[i][j];
        -:  440:
        -:  441:    // Regra 1: riscar em 'novo' minúsculas de cada branca em 'orig'
        8:  442:    for (int i = 0; i < orig.linhas; i++) {
branch  0 taken 6
branch  1 taken 2 (fallthrough)
       24:  443:        for (int j = 0; j < orig.colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  444:            if (isupper((unsigned char)orig.tabuleiro[i][j])) {
branch  0 taken 6 (fallthrough)
branch  1 taken 12
        6:  445:                char c = tolower(orig.tabuleiro[i][j]);
       24:  446:                for (int col = 0; col < orig.colunas; col++) {
branch  0 taken 18
branch  1 taken 6
       18:  447:                    if (orig.tabuleiro[i][col] == c && novo[i][col] != '#') {
branch  0 taken 1 (fallthrough)
branch  1 taken 17
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  448:                        novo[i][col] = '#'; alteracoes++;
        -:  449:                    }
        -:  450:                }
       24:  451:                for (int lin = 0; lin < orig.linhas; lin++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
      18*:  452:                    if (orig.tabuleiro[lin][j] == c && novo[lin][j] != '#') {
branch  0 taken 0 (fallthrough)
branch  1 taken 18
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  453:                        novo[lin][j] = '#'; alteracoes++;
        -:  454:                    }
        -:  455:                }
        -:  456:            }
        -:  457:        }
        -:  458:    }
        -:  459:
        -:  460:    // Regra 2: pintar vizinhos de '#' em 'orig'
        2:  461:    const int di[4] = {-1,1,0,0}, dj[4] = {0,0,-1,1};
        8:  462:    for (int i = 0; i < orig.linhas; i++) {
branch  0 taken 6
branch  1 taken 2
       24:  463:        for (int j = 0; j < orig.colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  464:            if (orig.tabuleiro[i][j] == '#') {
branch  0 taken 4
branch  1 taken 14
       20:  465:                for (int d = 0; d < 4; d++) {
branch  0 taken 16
branch  1 taken 4 (fallthrough)
       16:  466:                    int ni = i + di[d], nj = j + dj[d];
       16:  467:                    if (ni >= 0 && ni < orig.linhas && nj >= 0 && nj < orig.colunas
branch  0 taken 14 (fallthrough)
branch  1 taken 2
branch  2 taken 14 (fallthrough)
branch  3 taken 0
branch  4 taken 12 (fallthrough)
branch  5 taken 2
branch  6 taken 11 (fallthrough)
branch  7 taken 1
       11:  468:                        && islower((unsigned char)orig.tabuleiro[ni][nj])
branch  0 taken 5 (fallthrough)
branch  1 taken 6
        5:  469:                        && novo[ni][nj] != toupper((unsigned char)orig.tabuleiro[ni][nj])) {
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4:  470:                        novo[ni][nj] = toupper((unsigned char)orig.tabuleiro[ni][nj]);
        4:  471:                        alteracoes++;
        -:  472:                    }
        -:  473:                }
        -:  474:            }
        -:  475:        }
        -:  476:    }
        -:  477:
        -:  478:    // Regra 3: evitar isolamento de brancas — usar conexão completa simulada
        -:  479:// Regra 3 corrigida: evitar isolamento E repetições
        8:  480:for (int i = 0; i < orig.linhas; i++) {
branch  0 taken 6
branch  1 taken 2
       24:  481:    for (int j = 0; j < orig.colunas; j++) {
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  482:        if (islower((unsigned char)orig.tabuleiro[i][j])) {
branch  0 taken 5 (fallthrough)
branch  1 taken 13
        -:  483:            // Verifica se riscar isolaria as brancas
        5:  484:            if (!conexao_valida_apos_risco(&orig, i, j)) {
call    0 returned 5
branch  1 taken 1 (fallthrough)
branch  2 taken 4
        1:  485:                char mai = toupper((unsigned char)orig.tabuleiro[i][j]);
        -:  486:                
        -:  487:                // Verifica se a conversão para maiúscula é segura
        1:  488:                bool pode_pintar = true;
        -:  489:                
        -:  490:                // Verifica repetição na linha
        4:  491:                for (int x = 0; x < orig.colunas; x++) {
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        3:  492:                    if (x != j && isupper(novo[i][x]) && novo[i][x] == mai) {
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        -:  493:                        pode_pintar = false;
        -:  494:                        break;
        -:  495:                    }
        -:  496:                }
        -:  497:                
        -:  498:                // Verifica repetição na coluna
        1:  499:                if (pode_pintar) {
branch  0 taken 1
branch  1 taken 0
        4:  500:                    for (int y = 0; y < orig.linhas; y++) {
branch  0 taken 3
branch  1 taken 1 (fallthrough)
       3*:  501:                        if (y != i && isupper(novo[y][j]) && novo[y][j] == mai) {
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
branch  4 never executed (fallthrough)
branch  5 never executed
        -:  502:                            pode_pintar = false;
        -:  503:                            break;
        -:  504:                        }
        -:  505:                    }
        -:  506:                }
        -:  507:                
        -:  508:                // Aplica apenas se não houver repetições
        1:  509:                if (pode_pintar && novo[i][j] != mai) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:  510:                    novo[i][j] = mai;
    #####:  511:                    alteracoes++;
        -:  512:                }
        -:  513:            }
        -:  514:        }
        -:  515:    }
        -:  516:}
        -:  517:    // Copia 'novo' para o tabuleiro
        8:  518:    for (int i = 0; i < orig.linhas; i++)
branch  0 taken 6
branch  1 taken 2 (fallthrough)
       24:  519:        for (int j = 0; j < orig.colunas; j++)
branch  0 taken 18
branch  1 taken 6 (fallthrough)
       18:  520:            t->tabuleiro[i][j] = novo[i][j];
        -:  521:
        2:  522:    printf("Alterações aplicadas: %d\n", alteracoes);
call    0 returned 2
        2:  523:}
        -:  524:
function busca_solucao called 10 returned 100% blocks executed 70%
       10:  525:bool busca_solucao(Tabuleiro *t) {
        -:  526:
       10:  527:    if (violacao_basica(t)) return false;
branch  0 taken 10 (fallthrough)
branch  1 taken 0
        -:  528:
       10:  529:    if (completo(t)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 9
        1:  530:        return verificar_conectividade(t); // Conectividade só no final
call    0 returned 1
        -:  531:    }
        -:  532:
        -:  533:    // 4) Escolha da célula
        -:  534:    int bi = -1, bj = -1;
       27:  535:    for (int i = 0; i < t->linhas && bi < 0; i++) {
branch  0 taken 24 (fallthrough)
branch  1 taken 3
branch  2 taken 18
branch  3 taken 6 (fallthrough)
       54:  536:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 45
branch  1 taken 9 (fallthrough)
       45:  537:            if (islower((char)t->tabuleiro[i][j])) {
branch  0 taken 36 (fallthrough)
branch  1 taken 9
        -:  538:                bi = i; bj = j; break;
        -:  539:            }
        -:  540:        }
        -:  541:    }
        -:  542:
        -:  543:    // 5) Tenta pintar de branco
        -:  544:    {
        9:  545:        Tabuleiro copia = copia_tabuleiro(t);
call    0 returned 9
        9:  546:        copia.tabuleiro[bi][bj] = toupper((char)copia.tabuleiro[bi][bj]);
        9:  547:        if (busca_solucao(&copia)) {
call    0 returned 9
branch  1 taken 9 (fallthrough)
branch  2 taken 0
        9:  548:            *t = copia;
        9:  549:            return true;
        -:  550:        }
        -:  551:    }
        -:  552:
        -:  553:    // 6) Tenta riscar
        -:  554:    {
    #####:  555:        Tabuleiro copia = copia_tabuleiro(t);
call    0 never executed
    #####:  556:        copia.tabuleiro[bi][bj] = '#';
    #####:  557:        if (!violacao_basica(&copia)) { // Só continua se não houver '#' adjacentes
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  558:            if (busca_solucao(&copia)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  559:                *t = copia;
    #####:  560:                return true;
        -:  561:            }
        -:  562:        }
        -:  563:    }
        -:  564:
    #####:  565:    return false;
        -:  566:}
        -:  567:
function comando_R called 1 returned 100% blocks executed 78%
        1:  568:void comando_R(Tabuleiro *t) {
        1:  569:    Tabuleiro backup = copia_tabuleiro(t);
call    0 returned 1
        -:  570:
        1:  571:    if (!busca_solucao(t)) {
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  572:        printf("Não foi possível resolver o tabuleiro.\n");
call    0 never executed
    #####:  573:        *t = backup;
    #####:  574:        return;
        -:  575:    }
        -:  576:
        1:  577:    printf("Solução encontrada:\n");
call    0 returned 1
        1:  578:    imprimirTabuleiro(t->tabuleiro, t->linhas, t->colunas);
call    0 returned 1
        -:  579:}
        -:  580:
function copia_tabuleiro called 10 returned 100% blocks executed 100%
       10:  581:Tabuleiro copia_tabuleiro(Tabuleiro *t) {
       10:  582:    Tabuleiro c;
       10:  583:    c.linhas = t->linhas;
       10:  584:    c.colunas = t->colunas;
       40:  585:    for (int i = 0; i < t->linhas; i++) {
branch  0 taken 30
branch  1 taken 10 (fallthrough)
       30:  586:        memcpy(c.tabuleiro[i], t->tabuleiro[i], t->colunas);
        -:  587:    }
       10:  588:    return c;
        -:  589:}
        -:  590:
        -:  591:// Verifica se há alguma violação das regras básicas do jogo
function violacao_basica called 10 returned 100% blocks executed 61%
       10:  592:bool violacao_basica(Tabuleiro *t) {
        -:  593:    // 1a) Verificar repetições de letras brancas (maiúsculas) nas linhas
       40:  594:    for (int i = 0; i < t->linhas; i++) {
branch  0 taken 30
branch  1 taken 10
       30:  595:        int cnt[26] = {0}; // Contador de letras A-Z
      120:  596:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 90
branch  1 taken 30 (fallthrough)
       90:  597:            char c = t->tabuleiro[i][j];
       90:  598:            if (isupper((char)c)) { // Se for uma letra maiúscula
branch  0 taken 45 (fallthrough)
branch  1 taken 45
      45*:  599:                if (++cnt[c - 'A'] > 1) return true; // Letra repetida → violação
branch  0 taken 0 (fallthrough)
branch  1 taken 45
        -:  600:            }
        -:  601:        }
        -:  602:    }
        -:  603:
        -:  604:    // 1b) Verificar repetições de letras brancas (maiúsculas) nas colunas
       40:  605:    for (int j = 0; j < t->colunas; j++) {
branch  0 taken 30
branch  1 taken 10 (fallthrough)
       30:  606:        int cnt[26] = {0}; // Contador de letras A-Z
      120:  607:        for (int i = 0; i < t->linhas; i++) {
branch  0 taken 90
branch  1 taken 30 (fallthrough)
       90:  608:            char c = t->tabuleiro[i][j];
       90:  609:            if (isupper((char)c)) {
branch  0 taken 45 (fallthrough)
branch  1 taken 45
      45*:  610:                if (++cnt[c - 'A'] > 1) return true; // Letra repetida → violação
branch  0 taken 0 (fallthrough)
branch  1 taken 45
        -:  611:            }
        -:  612:        }
        -:  613:    }
        -:  614:
        -:  615:    // 1c) Verificar se cada célula riscada '#' tem pelo menos um vizinho branco
       10:  616:    int di[] = {-1, 1, 0, 0}; // deslocamentos para cima, baixo, esquerda, direita
       10:  617:    int dj[] = {0, 0, -1, 1};
       40:  618:    for (int i = 0; i < t->linhas; i++) {
branch  0 taken 30
branch  1 taken 10
      120:  619:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 90
branch  1 taken 30 (fallthrough)
       90:  620:            if (t->tabuleiro[i][j] == '#') {
branch  0 taken 0
branch  1 taken 90
    #####:  621:                bool tem_branco = false; // Flag para saber se há vizinho branco
    #####:  622:                for (int d = 0; d < 4; d++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  623:                    int ni = i + di[d];
    #####:  624:                    int nj = j + dj[d];
        -:  625:                    // Verifica se a posição vizinha está dentro dos limites do tabuleiro
    #####:  626:                    if (ni >= 0 && ni < t->linhas && nj >= 0 && nj < t->colunas) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
        -:  627:                        // Se há uma casa branca vizinha
    #####:  628:                        if (isupper((char)t->tabuleiro[ni][nj])) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  629:                            tem_branco = true;
        -:  630:                            break;
        -:  631:                        }
        -:  632:                    }
        -:  633:                }
    #####:  634:                if (!tem_branco) return true; // '#' isolado → violação
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  635:            }
        -:  636:        }
        -:  637:    }
        -:  638:
        -:  639:    // 1d) Verificar se existem dois '#' adjacentes (não permitido)
       40:  640:    for (int i = 0; i < t->linhas; i++) {
branch  0 taken 30
branch  1 taken 10 (fallthrough)
      120:  641:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 90
branch  1 taken 30 (fallthrough)
       90:  642:            if (t->tabuleiro[i][j] == '#') {
branch  0 taken 0
branch  1 taken 90
    #####:  643:                for (int d = 0; d < 4; d++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  644:                    int ni = i + di[d], nj = j + dj[d];
        -:  645:                    // Verifica se a posição vizinha está dentro do tabuleiro
    #####:  646:                    if (ni >= 0 && ni < t->linhas && nj >= 0 && nj < t->colunas) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    #####:  647:                        if (t->tabuleiro[ni][nj] == '#') {
branch  0 never executed (fallthrough)
branch  1 never executed
        -:  648:                            return true; // Dois '#' adjacentes → violação
        -:  649:                        }
        -:  650:                    }
        -:  651:                }
        -:  652:            }
        -:  653:        }
        -:  654:    }
        -:  655:
        -:  656:    // Nenhuma violação encontrada
        -:  657:    return false;
        -:  658:}
        -:  659:
        -:  660:// 2) Testa se o tabuleiro está completo (não há minúsculas)
function completo called 10 returned 100% blocks executed 100%
       10:  661:bool completo(Tabuleiro *t) {
       22:  662:    for (int i = 0; i < t->linhas; i++) {
branch  0 taken 21
branch  1 taken 1 (fallthrough)
       66:  663:        for (int j = 0; j < t->colunas; j++) {
branch  0 taken 54
branch  1 taken 12 (fallthrough)
       54:  664:            if (islower((unsigned char)t->tabuleiro[i][j]))
branch  0 taken 45 (fallthrough)
branch  1 taken 9
        -:  665:                return false;
        -:  666:        }
        -:  667:    }
        -:  668:    return true;
        -:  669:}
        -:  670:
        -:  671:// Funções de interface
function imprimir_comandos called 1 returned 100% blocks executed 100%
        1:  672:void imprimir_comandos() {
        1:  673:    printf("Comandos disponíveis:\n");
call    0 returned 1
        1:  674:    printf("g - Gravar o jogo atual no ficheiro\n");
call    0 returned 1
        1:  675:    printf("l - Ler o estado do jogo num ficheiro\n");
call    0 returned 1
        1:  676:    printf("b letra nr - Pintar de branco\n");
call    0 returned 1
        1:  677:    printf("r letra nr - Riscar\n");
call    0 returned 1
        1:  678:    printf("v - Verificar restrições\n");
call    0 returned 1
        1:  679:    printf("a - Aplicar inferências\n");
call    0 returned 1
        1:  680:    printf("A - Repetir inferências até não haver mudanças\n");
call    0 returned 1
        1:  681:    printf("R - Resolver o jogo\n");
call    0 returned 1
        1:  682:    printf("d - Desfazer última ação\n");
call    0 returned 1
        1:  683:    printf("s - Sair\n");
call    0 returned 1
        1:  684:}
